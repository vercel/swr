---
title: 'Annonce SWR 2.0'
image: https://assets.vercel.com/image/upload/v1670542323/swr/v2.png
description: 'Annonce SWR 2.0: Nouvelle API de mutation et am√©lioration des capacit√©s de l‚ÄôUI optimiste, nouveaux outils d√©veloppeur, meilleur support du rendu simultan√©, et bien plus.'
date: 9 D√©cembre 2022
---

import { Callout } from 'nextra-theme-docs'
import { Bleed } from 'nextra-theme-docs'

import Authors, { Author } from 'components/authors'
import Video from 'components/video'

# Annonce SWR 2.0 [#announcing-swr-20]

<Authors date="9 D√©cembre 2022" by="par">
  <Author name="Shu Ding" link="https://twitter.com/shuding_" />
  <Author name="Jiachi Liu" link="https://twitter.com/huozhi" />
  <Author name="Toru Kobayashi" link="https://twitter.com/koba04" />
  <Author name="Yixuan Xu" link="https://twitter.com/yixuanxu94" />
</Authors>

Nous sommes heureux d‚Äôannoncer la release de SWR 2.0, la populaire librairie de r√©cup√©ration de donn√©es pour React qui permet aux composants de r√©cup√©rer, mettre en cache et muter des donn√©es et de garder l‚ÄôUI √† jour avec les changements de ces donn√©es au fil du temps.

Cette nouvelle version vient avec de nombreuses am√©liorations et de nouvelles fonctionnalit√©s, telles que de nouvelles API de mutation, des capacit√©s d‚ÄôUI optimiste am√©lior√©es, de nouveaux outils d√©veloppeur et un meilleur support du rendu simultan√©. Nous souhaitons remercier chaleureusement tous les contributeurs et mainteneurs qui ont rendu cette release possible.

## Mutation et UI Optimiste [#mutation-and-optimistic-ui]

### useSWRMutation [#useswrmutation]

La mutation est une partie important du processus de r√©cup√©ration des donn√©es. Elles vous permettent de faire des changements dans vos donn√©es localement et √† distance. Notre API `mutate` existante vous permet de revalider et de modifier vos donn√©es manuellement. Avec SWR 2.0, le nouveau hook `useSWRMutation` rend encore plus simple la modification des donn√©es √† distance en utilisant une API d√©clarative. Vous pouvez configurer une mutation en utilisant le hook, et l‚Äôactiver plus tard :

```jsx {11,16}
import useSWRMutation from 'swr/mutation'

async function sendRequest(url, { arg }) {
  return fetch(url, {
    method: 'POST',
    body: JSON.stringify(arg)
  })
}

function App() {
  const { trigger, isMutating } = useSWRMutation('/api/user', sendRequest)

  return (
    <button
      disabled={isMutating}
      onClick={() => trigger({ username: 'johndoe' })}
    >{
      isMutating ? 'Creation...' : 'Utilisateur Cr√©√©'
    }</button>
  )
}
```

L‚Äôexemple ci-dessus d√©finit une mutation `sendRequest` qui affecte la ressource `‚Äô/api/user‚Äô`. Contrairement √† `useSWR`, `useSWRMutation` ne d√©marre pas imm√©diatement la requ√™te lors du rendu. Au lieu de cela, il retourne une fonction `trigger` qui peut √™tre appel√©e plus tard pour d√©marrer manuellement la mutation.

La fonction `sendRequest` sera appel√©e lorsque le bouton sera cliqu√©, avec l‚Äôargument suppl√©mentaire `{ username: ‚Äôjohndoe‚Äô }`. La valeur de `isMutating` sera d√©finie sur `true` jusqu‚Äô√† ce que la mutation soit termin√©e.

De plus, ce nouveau hook r√©sout d‚Äôautres probl√®mes que vous pouvez rencontrer avec les mutations :

- Mise √† jour optimiste de l‚ÄôUI pendant que les donn√©es sont mut√©es
- R√©tablisement automatique en cas d‚Äô√©chec de la mutation
- √âviter les √©ventuels probl√®mes de concurrence entre `useSWR` et d‚Äôautres mutations de la m√™me ressource
- Alimenter le cache de `useSWR` apr√®s la fin de la mutation
- ...

Vous pouvez trouver des r√©f√©rences d‚ÄôAPI d√©taill√©es et des exemples en lisant la [documentation](/docs/mutation#useswrmutation) ou en parcourant les sections suivantes.

### UI Optimiste [#optimistic-ui]

L‚ÄôUI Optimiste est un excellent mod√®le pour cr√©er des sites web qui semblent rapides et r√©actifs ; cependant, il peut √™tre difficile √† impl√©menter correctement. SWR 2.0 a ajout√© de nouvelles options puissantes pour le rendre plus facile.

Disons que nous avons une API qui ajoute un nouvel √©l√©ment √† une liste de t√¢ches et l‚Äôenvoie au serveur :

```jsx
await addNewTodo('New Item')
```

Dans notre UI, nous utilisons un hook `useSWR` pour afficher la liste de t√¢ches, avec un bouton "Ajouter un nouvel √©l√©ment" qui d√©clenche cette requ√™te et demande √† SWR de recharger les donn√©es via `mutate()` :

```jsx {7,8}
const { mutate, data } = useSWR('/api/todos')

return <>
  <ul>{/* Afficher les don√©es */}</ul>

  <button onClick={async () => {
    await addNewTodo('Nouvel Element')
    mutate()
  }}>
    Ajouter un Nouvel Element
  </button>
</>
```

Cependant, la requ√™te `await addNewTodo(...)` peut √™tre tr√®s lente. Lorsqu‚Äôelle est en cours, les utilisateurs voient toujours l‚Äôancienne liste m√™me si nous pouvons d√©j√† savoir √† quoi ressemblera la nouvelle liste. Avec la nouvelle option `optimisticData`, nous pouvons afficher la nouvelle liste de mani√®re optimiste, avant que le serveur ne r√©ponde :

```jsx {8}
const { mutate, data } = useSWR('/api/todos')

return <>
  <ul>{/* Afficher les don√©es */}</ul>

  <button onClick={() => {
    mutate(addNewTodo('Nouvel Element'), {
      optimisticData: [...data, 'Nouvel Element'],
    })
  }}>
    Ajouter un Nouvel Element
  </button>
</>
```

SWR va imm√©diatement mettre √† jour les `data` avec la valeur `optimisticData`, et ensuite envoyer la requ√™te au serveur. Une fois la requ√™te termin√©e, SWR va revalider la ressource pour s‚Äôassurer qu‚Äôelle est √† jour.

Comme beaucoup d‚ÄôAPI, si la requ√™te `addNewTodo(...)` nous renvoie les derni√®res donn√©es du serveur, nous pouvons directement afficher ce r√©sultat (au lieu de d√©marrer une nouvelle revalidation) ! Il y a une nouvelle option `populateCache` pour dire √† SWR de mettre √† jour les donn√©es locales avec la r√©ponse de la mutation :

```jsx {9}
const { mutate, data } = useSWR('/api/todos')

return <>
  <ul>{/* Afficher les don√©es */}</ul>

  <button onClick={() => {
    mutate(addNewTodo('Nouvel Element'), {
      optimisticData: [...data, 'Nouvel Element'],
      populateCache: true,
    })
  }}>
    Ajouter un Nouvel Element
  </button>
</>
```

En m√™me temps, nous n‚Äôavons plus besoin d‚Äôune nouvelle revalidation, car les donn√©es de r√©ponse proviennent de la source de confiance, nous pouvons d√©sactiver cet revalidation avec l‚Äôoption `revalidate` :

```jsx {10}
const { mutate, data } = useSWR('/api/todos')

return <>
  <ul>{/* Afficher les don√©es */}</ul>

  <button onClick={() => {
    mutate(addNewTodo('Nouvel Element'), {
      optimisticData: [...data, 'Nouvel Element'],
      populateCache: true,
      revalidate: false,
    })
  }}>
    Ajouter un Nouvel Element
  </button>
</>
```

Enfin, si `addNewTodo(...)` √©choue avec une exception, nous pouvons r√©tablire les donn√©es optimistes (`[...data, 'Nouvel Element']`) que nous venons de d√©finir, en d√©finissant `rollbackOnError` sur `true` (qui est √©galement l‚Äôoption par d√©faut). Lorsque cela se produit, SWR va r√©tablir les `data` √† la valeur pr√©c√©dente.

```jsx {11}
const { mutate, data } = useSWR('/api/todos')

return <>
  <ul>{/* Afficher les don√©es */}</ul>

  <button onClick={() => {
    mutate(addNewTodo('Nouvel Element'), {
      optimisticData: [...data, 'Nouvel Element'],
      populateCache: true,
      revalidate: false,
      rollbackOnError: true,
    })
  }}>
    Ajouter un Nouvel Element
  </button>
</>
```

Toutes ces options sont √©galement disponibles dans le nouveau hook `useSWRMutation`. Pour en savoir plus, vous pouvez consulter notre [documentation](/docs/mutation#optimistic-updates). Et voici une d√©mo montrant ce comportement :

<Video
  src="/video/optimistic-ui.mp4"
  caption="UI Optimiste avec r√©tablisement automatique en cas d‚Äôerreur"
  ratio={223/584}
/>

### Multiple Cl√© de Mutation [#mutate-multiple-keys]

L‚ÄôAPI global `mutate` peut maintenant accepter une fonction de filtre, o√π vous pouvez muter ou revalider des cl√©s sp√©cifiques. Cela sera utile pour, par exemple, l‚Äôinvalidation de toutes les donn√©es mises en cache. Pour en savoir plus, vous pouvez lire [Mutate Multiple Keys](/docs/mutation#mutate-multiple-items) dans la documentation.

```jsx
import { mutate } from 'swr'
// Ou depuis le hook si vous avez personnalis√© votre fournisseur de cache:
// { mutate } = useSWRConfig()

// Mutation d‚Äôune seule ressource
mutate(key)

// Mutation de plusieurs ressources et effacement du cache (d√©fini sur undefined)
mutate(
  key => typeof key === 'string' && key.startsWith('/api/item?id='),
  undefined,
  { revalidate: false }
)
```

## SWR Outils de D√©veloppement [#swr-devtools]

[SWRDevTools](https://swr-devtools.vercel.app) est une extention de navigateur qui vous aide √† d√©bugger votre cache SWR et les r√©sultats de r√©cup√©ration. Consultez notre section [devtools](/docs/advanced/devtools) pour savoir comment utiliser les outils de d√©veloppement dans votre application.

![](/img/devtools/cache-view.jpg)

## Prechargement des Donn√©es [#preloading-data]

Le pr√©chargement des donn√©es peut am√©liorer consid√©rablement l‚Äôexp√©rience utilisateur. Si vous savez que la ressource sera utilis√©e plus tard dans l‚Äôapplication, vous pouvez utiliser la nouvelle API `preload` pour charger les donn√©es plus t√¥t :

```jsx {6}
import useSWR, { preload } from 'swr'

const fetcher = (url) => fetch(url).then((res) => res.json())

// Vous pouvez appeler la fonction preload n‚Äôimporte o√π
preload('/api/user', fetcher)

function Profile() {
  // Le composant qui utilise les donn√©es:
  const { data, error } = useSWR('/api/user', fetcher)
  // ...
}

export function Page () {
  return <Profile/>
}
```

Dans cet exemple, l‚ÄôAPI `preload` est appel√©e globalement. Cela signifie que que le prechargement des resources commence avant que React ne d√©clanche le rendu.
Et lorsque le composant `Profile` est rendu, les donn√©es peuvent probablement √™tre disponibles. Si ce n‚Äôest pas le cas, le hook `useSWR` r√©utilisera la requ√™te de prechargement en cours au lieu d‚Äôen d√©marrer une nouvelle.

L‚ÄôAPI `preload` peut aussi √™tre utilis√©e dans des cas comme le prechargement des donn√©es pour une autre page qui sera probablement rendue. Vous pouvez trouver plus d‚Äôinformations sur le prechargement des donn√©es avec SWR [ici](/docs/prefetching).

## `isLoading` [#isloading]

`isLoading` est le nouvel √©tat retourn√© par `useSWR`, qui indique **si la requ√™te est toujours en cours et qu‚Äôaucune donn√©e n‚Äôa encore √©t√© charg√©e**. Pr√©c√©demment, `isValidating` repr√©sentait √† la fois l‚Äô√©tat de chargement initial et l‚Äô√©tat de revalidation. Il fallait donc v√©rifier si `data` et `error` √©taient `undefined` pour d√©terminer s‚Äôil s‚Äôagissait de l‚Äô√©tat de chargement initial.

Maintenant, c‚Äôest plus simple et vous pouvez utiliser directement la valeur `isLoading` pour afficher un message de chargement :

```jsx
import useSWR from 'swr'

function Profile() {
  const { data, isLoading } = useSWR('/api/user', fetcher)

  if (isLoading) return <div>chargement...</div>
  return <div>bonjour {data.name}!</div>
}
```

Notez que `isValidating` est toujours pr√©sent, vous pouvez donc toujours l‚Äôutiliser pour afficher un indicateur de chargement pour les revalidations.

<Callout emoji="üìù">
  Nous avons ajout√© la nouvelle page [Comprendre SWR](/docs/advanced/understanding) pour d√©crire comment SWR retourne les valeurs, ce qui inclut la diff√©rence entre `isValidating` et `isLoading`, et comment les combiner pour am√©liorer l‚Äôexp√©rience utilisateur.
</Callout>

## Conservation de l‚Äô√âtat Pr√©c√©dent [#preserving-previous-state]

L‚Äôoption `keepPreviousData` est une nouvelle fonctionnalit√© qui vous permet de conserver les donn√©es qui ont √©t√© r√©cup√©r√©es pr√©c√©demment. Cela am√©liore consid√©rablement l‚Äôexp√©rience utilisateur lorsque vous r√©cup√©rez des donn√©es en fonction d‚Äôactions utilisateur qui se produisent en temps r√©el, comme avec une fonction de recherche en direct, o√π la cl√© de la ressource change :

```jsx {5}
function Search() {
  const [search, setSearch] = React.useState('');

  const { data, isLoading } = useSWR(`/search?q=${search}`, fetcher, {
    keepPreviousData: true
  })

  return (
    <div>
      <input
        type="text"
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder="Rechercher..."
      />

      <div className={isLoading ? "chargement" : ""}>
        {data?.products.map(item => <Product key={item.id} name={item.name} />)}
      </div>
    </div>
  );
}
```

<Video
  src="https://user-images.githubusercontent.com/3676859/163695903-a3eb1259-180e-41e0-821e-21c320201194.mp4"
  caption="Convervation des pr√©c√©dent r√©sultat de recherche avec keepPreviousData activable"
  ratio={640/730}
/>

Allez voir le code sur [CodeSandbox](https://codesandbox.io/s/swr-keeppreviousdata-fsjz3m) et vous pouvez en lire plus √† ce sujet [ici](/docs/advanced/understanding#return-previous-data-for-better-ux).

## Extension des Configurations [#extending-configurations]

`SWRConfig` peut maintenant accepter comme valeur une fonction. Lorsque vous avez plusieurs niveaux de `<SWRConfig>`, le niveau interne re√ßoit la configuration parent et retourne une nouvelle configuration. Ce changement rend la configuration de SWR plus flexible dans une grande codebase. Vous pouvez trouver plus d‚Äôinformations [ici](/docs/global-configuration).

```jsx
<SWRConfig
  value={parentConfig => ({
    dedupingInterval: parentConfig.dedupingInterval * 5,
    refreshInterval: 100,
  })}
>
  <Page />
</SWRConfig>
```

## Am√©lioration du Support de React 18 [#improved-react-18-support]

SWR a √©t√© mis √† jour pour utiliser les API `useSyncExternalStore` et `startTransition` de React 18. Celles-ci assurent une plus grande coh√©rence lors du rendu de l‚ÄôUI simultan√©ment. Ce changement ne n√©cessite aucune modification du code utilisateur et tous les d√©veloppeurs en b√©n√©ficieront directement. Shims est inclus pour React 17 et les pr√©c√©demment versions.

SWR 2.0 et toutes les nouvelles fonctionnalit√©s sont toujours compatibles avec React 16 et 17.

## Guide de Migration [#migration-guide]

### La fonction de r√©cup√©ration n‚Äôaccepte plus plusieurs param√®tres [#fetcher-no-longer-accepts-multiple-arguments]

`key` est pass√© comme un seul argument.

```diff
- useSWR([1, 2, 3], (a, b, c) => {
+ useSWR([1, 2, 3], ([a, b, c]) => {
  assert(a === 1)
  assert(b === 2)
  assert(c === 3)
})
```

### La Mutation globale n‚Äôaccept plus la fonction `getKey` [#global-mutate-no-longer-accepts-a-getkey-function]

Maintenant, si vous passez une fonction √† la mutation globale, elle sera utilis√©e comme un [filtre](/blog/swr-v2#mutate-multiple-keys). Pr√©c√©demment, vous pouviez passer une fonction qui renvoie une cl√© √† la mutation globale :

```diff
- mutate(() => '/api/item') // une fonction qui revoie une cl√©
+ mutate('/api/item')       // pour transformer la cl√©, passez-la directement
```

### Nouvelle Propri√©t√© Requise `keys()` pour l‚ÄôInterface Cache [#new-required-property-keys-for-cache-interface]

Quand vous utilisez votre propre impl√©mentation de cache, l‚Äôinterface Cache demande maintenant une m√©thode `keys()` qui retourne toutes les cl√©s de l‚Äôobjet cache, similaire aux instances JavaScript Map.

```diff
interface Cache<Data> {
  get(key: string): Data | undefined
  set(key: string, value: Data): void
  delete(key: string): void
+ keys(): IterableIterator<string>
}
```

### Modification de la Structure Interne du Cache [#changed-cache-internal-structure]

La structure interne des donn√©es du cache est un objet qui contient tous les √©tats actuels.

```diff
- assert(cache.get(key) === data)
+ assert(cache.get(key) === { data, error, isValidating })

// getter
- cache.get(key)
+ cache.get(key)?.data

// setter
- cache.set(key, data)
+ cache.set(key, { ...cache.get(key), data })
```

<Callout emoji="üö®" type="error">
  Vous ne devriez pas √©crire directement dans le cache, cela peut causer un comportement inpr√©visible.
</Callout>

### `SWRConfig.default` est renomm√© `SWRConfig.defaultValue` [#swrconfigdefault-is-renamed-as-swrconfigdefaultvalue]

`SWRConfig.defaultValue` est la propri√©t√© pour acc√©der √† la configuration SWR par d√©faut.

```diff
- SWRConfig.default
+ SWRConfig.defaultValue
```

### Le Type `InfiniteFetcher` est renomm√©  `SWRInfiniteFetcher` [#type-infinitefetcher-is-renamed-as-swrinfinitefetcher]

```diff
- import type { InfiniteFetcher } from 'swr/infinite'
+ import type { SWRInfiniteFetcher } from 'swr/infinite'
```

### Evitez Suspense sur le Serveur [#avoid-suspense-on-server]

Si vous voulez utilisez `suspense: true` avec SWR c√¥t√© serveur, incluant le pr√©-rendu dans Next.js, vous devez fournir des donn√©es initiales via [`fallbackData` ou `fallback`](/docs/with-nextjs#pre-rendering-with-default-data). Aujourd‚Äôhui, cela signifie que vous ne pouvez pas utiliser Suspense pour r√©cup√©rer des donn√©es c√¥t√© serveur. Vos deux autres options sont de faire de la r√©cup√©ration de donn√©es c√¥t√© client ou de faire r√©cup√©rer les donn√©es par votre framework (comme le fait `getStaticProps` dans Next.js).

### ES2018 comme cible de Build [#es2018-as-the-build-target]

Si vous voulez supporter IE 11, vous devez cibler ES5 dans votre framework ou votre bundler. Ce changement a permis une am√©lioration des performances sur le SSR, et garde la taille du bundle petite.

## Changelog [#changelog]

Lisez le Changelog complet [sur GitHub](https://github.com/vercel/swr/releases).

## Le Future & Merci ! [#the-future--thank-you]

Avec la sortie de [Next.js 13](https://nextjs.org/blog/next-13), nous voyons beaucoup de nouvelles choses passionnantes ainsi que des changements de paradigmes dans l‚Äô√©cosyst√®me React : [React Server Components](https://beta.nextjs.org/docs/rendering/server-and-client-components), streaming SSR, [async components](https://beta.nextjs.org/docs/data-fetching/fetching#asyncawait-in-server-components), et le [`use` hook](https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md#usepromise). Beaucoup d‚Äôentre eux sont li√©s √† la r√©cup√©ration de donn√©es, et certains d‚Äôentre eux ont des cas d‚Äôutilisation qui se chevauchent avec SWR.

Cependant, le b√ªt du projet SWR reste le m√™me. Nous voulons que cette librairie soit l√©g√®re, ind√©pendante de tout framework, et un peu _opinionated_ (i.e. revalider lors du focus). Au lieu d‚Äôessayer d‚Äô√™tre une solution standard, nous voulons nous concentrer sur les innovations qui rendent l‚ÄôUX meilleure. En attendant, nous faisons √©galement des recherches sur la fa√ßon d‚Äôam√©liorer SWR avec ces nouvelles capacit√©s de React.

Nous voulons aussi remercier tous les [143](https://github.com/vercel/swr/graphs/contributors) contributeurs (+ [106](https://github.com/vercel/swr-site/graphs/contributors) contributeurs de la documentation), ainsi que ceux qui nous ont aid√© ou donn√© des retours. Un merci sp√©cial √† [Toru Kobayashi](https://twitter.com/koba04) pour tout son travail sur les outils d√©veloppeur et la documentation - nous n‚Äôaurions pas pu le faire sans toi !
