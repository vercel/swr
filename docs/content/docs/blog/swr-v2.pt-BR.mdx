---
image: https://assets.vercel.com/image/upload/v1670542323/swr/v2.png
description: "Anunciando SWR 2.0: Novas APIs de muta√ß√£o e melhorias nas capacidades de UI otimista, novas ferramentas de desenvolvedor, melhor suporte para renderiza√ß√£o concorrente e muito mais."
date: December 9th, 2022
---

import { Callout } from 'nextra-theme-docs'
import { Bleed } from 'nextra-theme-docs'

import Authors, { Author } from 'components/authors'
import Video from 'components/video'

# Anunciando SWR 2.0 [#announcing-swr-20]

<Authors date="December 9th, 2022">
  <Author name="Shu Ding" link="https://twitter.com/shuding_" />
  <Author name="Jiachi Liu" link="https://twitter.com/huozhi" />
  <Author name="Toru Kobayashi" link="https://twitter.com/koba04" />
  <Author name="Yixuan Xu" link="https://twitter.com/yixuanxu94" />
</Authors>


N√≥s estamos muito felizes em anunciar o lan√ßamento do SWR 2.0, a popular biblioteca de busca de dados para React que permite que componentes busquem, armazenem em cache, alterem dados e que mant√©m a UI atualizada com as altera√ß√µes nesses dados ao longo do tempo. 

Essa nova vers√£o chega carregada com melhorias e novas funcionalidades, como novas APIs de muta√ß√£o, melhorias nas capacidades de UI otimista, novas ferramentas de desenvolvedor e melhor suporte para renderiza√ß√£o concorrente. Gostar√≠amos de agradecer a todos os contribuidores e mantenedores que tornaram esse lan√ßamento poss√≠vel.

## Muta√ß√£o e UI Otimista [#mutation-and-optimistic-ui]

### useSWRMutation [#useswrmutation]

Muta√ß√£o √© uma parte importante do processo de data fetching. Elas permitem que voc√™ fa√ßa altera√ß√µes em seus dados tanto localmente quanto remotamente. Nossa API existente `mutate` permite que voc√™ revalide e altere recursos manualmente. No SWR 2.0, o novo hook `useSWRMutation` torna ainda mais simples alterar dados remotamente usando uma API declarativa. Voc√™ pode configurar uma muta√ß√£o usando o hook e em seguida, ativ√°-la mais tarde:

```jsx {11,16}
import useSWRMutation from 'swr/mutation'

async function sendRequest(url, { arg }) {
  return fetch(url, {
    method: 'POST',
    body: JSON.stringify(arg)
  })
}

function App() {
  const { trigger, isMutating } = useSWRMutation('/api/user', sendRequest)

  return (
    <button
      disabled={isMutating}
      onClick={() => trigger({ username: 'johndoe' })}
    >{
      isMutating ? 'Criando...' : 'Criar usu√°rio'
    }</button>
  )
}
```

O exemplo acima define uma muta√ß√£o `sendRequest` que afeta o recurso `'/api/user'`. Ao contr√°rio de `useSWR`, `useSWRMutation` n√£o iniciar√° imediatamente a requisi√ß√£o ao renderizar. Em vez disso, ele retorna uma fun√ß√£o `trigger` que pode ser chamada posteriormente para iniciar manualmente a muta√ß√£o.

A fun√ß√£o `sendRequest` ser√° chamada quando o bot√£o for clicado, junto com o argumento extra `{ username: 'johndoe' }`. O valor de `isMutating` ser√° definido como `true` at√© que a muta√ß√£o tenha terminado.

Adicionalmente, esse novo hook resolve outros problemas que voc√™ pode ter com muta√ß√µes:

- Atualiza a UI otimisticamente enquanto os dados est√£o sendo alterados
- Reverte automaticamente quando a muta√ß√£o falha
- Evita qualquer potencial conflito entre `useSWR` e outras muta√ß√µes do mesmo recurso
- Preenche o cache do `useSWR` ap√≥s a muta√ß√£o ser conclu√≠da
- ...

Voc√™ pode achar refer√™ncias de API e exemplos mais detalhados lendo a [documenta√ß√£o](/docs/mutation#useswrmutation) ou rolando pelas pr√≥ximas se√ß√µes.

### UI Otimista [#optimistic-ui]

UI Otimista √© um exelente modelo para criar sites que sejam r√°pidos e responsivos; no entanto, pode ser dif√≠cil implement√°-lo corretamente. O SWR 2.0 adicionou algumas novas op√ß√µes poderosas para facilitar isso.

Vamos supor que tenhamos uma API que adiciona um novo item √† lista de tarefas e o envia ao servidor:

```jsx
await addNewTodo('Novo Item')
```

Na nossa UI, usamos um hook `useSWR` para exibir a lista de tarefas, com um bot√£o ‚ÄúAdicionar novo item‚Äù que dispara essa requisi√ß√£o e pede ao SWR para rebuscar os dados via `mutate()`:

```jsx {7,8}
const { mutate, data } = useSWR('/api/todos')

return <>
  <ul>{/* Exibir dados */}</ul>

  <button onClick={async () => {
    await addNewTodo('Novo Item')
    mutate()
  }}>
    Adicionar novo item
  </button>
</>
```

Entretanto, a requisi√ß√£o `await addNewTodo(...)` pode ser muito lenta. Quando estiver em andamento, os usu√°rios ainda ver√£o a lista antiga, mesmo que j√° saibamos como ser√° a nova lista. Com a nova op√ß√£o `optimisticData`, podemos mostrar a nova lista otimisticamente, antes que o servidor responda:

```jsx {8}
const { mutate, data } = useSWR('/api/todos')

return <>
  <ul>{/* Exibir dados */}</ul>

  <button onClick={() => {
    mutate(addNewTodo('Novo Item'), {
      optimisticData: [...data, 'Novo Item'],
    })
  }}>
    Adicionar novo item
  </button>
</>
```

O SWR ir√° imediatamente atualizar `data` com o valor de `optimisticData` e, em seguida, enviar a requisi√ß√£o ao servidor. Assim que a requisi√ß√£o terminar, o SWR revalidar√° o recurso para garantir que seja o mais recente.

Assim como muitas APIs, se a requisi√ß√£o `addNewTodo(...)` retornar os dados mais recentes do servidor, tamb√©m podemos exibir diretamente esse resultado (em vez de iniciar uma nova revalida√ß√£o)! Existe a nova op√ß√£o `populateCache` para dizer ao SWR para atualizar os dados locais com a resposta da muta√ß√£o:

```jsx {9}
const { mutate, data } = useSWR('/api/todos')

return <>
  <ul>{/* Exibir dados */}</ul>

  <button onClick={() => {
    mutate(addNewTodo('Novo Item'), {
      optimisticData: [...data, 'Novo Item'],
      populateCache: true,
    })
  }}>
    Adicionar novo item
  </button>
</>
```

Ao mesmo tempo, n√£o precisamos de outra revalida√ß√£o depois, pois os dados da resposta s√£o da fonte da verdade, podemos desativ√°-la com a op√ß√£o `revalidate`:

```jsx {10}
const { mutate, data } = useSWR('/api/todos')

return <>
  <ul>{/* Exibir dados */}</ul>

  <button onClick={() => {
    mutate(addNewTodo('Novo Item'), {
      optimisticData: [...data, 'Novo Item'],
      populateCache: true,
      revalidate: false,
    })
  }}>
    Adicionar novo item
  </button>
</>
```

Por √∫ltimo, se `addNewTodo(...)` falhar com uma exce√ß√£o, podemos reverter os dados otimistas (`[...data, 'Novo Item']`) que acabamos de definir, definindo `rollbackOnError` como `true` (que tamb√©m √© a op√ß√£o padr√£o). Quando isso acontece, o SWR reverter√° `data` para o valor anterior.

```jsx {11}
const { mutate, data } = useSWR('/api/todos')

return <>
  <ul>{/* Exibir dados */}</ul>

  <button onClick={() => {
    mutate(addNewTodo('Novo Item'), {
      optimisticData: [...data, 'Novo Item'],
      populateCache: true,
      revalidate: false,
      rollbackOnError: true,
    })
  }}>
    Adicionar novo item
  </button>
</>
```

Todas essas APIs s√£o suportadas no novo hook `useSWRMutation` tamb√©m. Para saber mais sobre elas, voc√™ pode conferir nossa [documenta√ß√£o](/docs/mutation#atualiza√ß√µes-otimistas). Aqui est√° uma demo mostrando esse comportamento:

<Video
  src="/video/optimistic-ui.mp4"
  caption="UI Otimista com revers√£o autom√°tica de erros"
  ratio={223/584}
/>

### Modificando M√∫ltiplas Chaves [#mutate-multiple-keys]

A API global `mutate` agora aceita uma fun√ß√£o de filtro, onde voc√™ pode mutar ou revalidar chaves espec√≠ficas. Isso ser√° √∫til para casos de uso como invalidar todos os dados em cache. Para saber mais, voc√™ pode ler [Modificando M√∫ltiplas Chaves](/docs/mutation#modificando-m√∫ltiplos-items) na documenta√ß√£o.

```jsx
import { mutate } from 'swr'
// Ou do hook se voc√™ tiver customizado seu provedor de cache:
// { mutate } = useSWRConfig()

// Modificar um √∫nico recurso
mutate(key)

// Modificar m√∫ltiplos recursos e limpar o cache (definir como undefined)
mutate(
  key => typeof key === 'string' && key.startsWith('/api/item?id='),
  undefined,
  { revalidate: false }
)
```

## SWR DevTools [#swr-devtools]

O [SWRDevTools](https://swr-devtools.vercel.app) √© uma extens√£o do navegador que ajuda voc√™ a depurar o cache do SWR e os resultados das requisi√ß√µes. Confira nossa [se√ß√£o de DevTools](/docs/advanced/devtools) para saber como usar o devtools em sua aplica√ß√£o.

![](/img/devtools/cache-view.jpg)

## Pr√©-carregando Dados [#preloading-data]

Precarregar dados pode melhorar a experi√™ncia do usu√°rio tremendamente. Se voc√™ souber que o recurso ser√° usado mais tarde na aplica√ß√£o, pode usar a nova API `preload` para come√ßar a carreg√°-lo mais cedo:

```jsx {6}
import useSWR, { preload } from 'swr'

const fetcher = (url) => fetch(url).then((res) => res.json())

// Voc√™ pode chamar a fun√ß√£o preload em qualquer lugar
preload('/api/user', fetcher)

function Profile() {
  // O componente que realmente usa os dados:
  const { data, error } = useSWR('/api/user', fetcher)
  // ...
}

export function Page () {
  return <Profile/>
}
```

Nesse exemplo, a `preload` API √© chamada no escopo global. Isso significa que come√ßamos a pr√©-carregar o recurso antes mesmo que o React comece a renderizar qualquer coisa.
E quando o componente `Profile` estiver sendo renderizado, os dados provavelmente j√° estar√£o dispon√≠veis. Se ainda estiver em andamento, o hook `useSWR` reutilizar√° essa solicita√ß√£o de pr√©-carregamento em andamento em vez de iniciar uma nova.

A `preload` API tamb√©m pode ser usada em casos como pr√©-carregar dados para outra p√°gina que provavelmente ser√° renderizada. Mais informa√ß√µes sobre pr√©-carregamento de dados com SWR podem ser encontradas [aqui](/docs/prefetching).

## `isLoading` [#isloading]

`isLoading` √© o novo estado retornado pelo `useSWR`, que indica **se a requisi√ß√£o ainda est√° em andamento e ainda n√£o h√° dados carregados**. Anteriormente, o estado `isValidating` representava tanto o estado de carregamento inicial quanto o estado de revalida√ß√£o, ent√£o t√≠nhamos que verificar se tanto `data` quanto `error` eram `undefined` para determinar se era o estado de carregamento inicial.

Agora, √© t√£o f√°cil que voc√™ pode usar o valor `isLoading` diretamente para renderizar uma mensagem de carregamento:

```jsx
import useSWR from 'swr'

function Profile() {
  const { data, isLoading } = useSWR('/api/user', fetcher)

  if (isLoading) return <div>carregando...</div>
  return <div>ol√° {data.name}!</div>
}
```

Note que `isValidating` ainda est√° presente, ent√£o voc√™ ainda pode us√°-lo para mostrar um indicador de carregamento para revalida√ß√µes.

<Callout emoji="üìù">
  N√≥s adicionamos a nova p√°gina [Entendendo SWR](/docs/advanced/understanding) para descrever como o SWR retorna valores, que inclui a diferen√ßa entre `isValidating` e `isLoading`, e como combin√°-los para melhorar a experi√™ncia do usu√°rio.
</Callout>

## Preservando o Estado Anterior [#preserving-previous-state]

A op√ß√£o `keepPreviousData` √© uma nova adi√ß√£o que permite manter os dados que foram buscados anteriormente. Isso melhora a UX imensamente quando voc√™ est√° buscando dados com base em a√ß√µes do usu√°rio acontecendo em tempo real, como com um recurso de pesquisa ao vivo, onde a `key` do recurso continua mudando:

```jsx {5}
function Search() {
  const [search, setSearch] = React.useState('');

  const { data, isLoading } = useSWR(`/search?q=${search}`, fetcher, {
    keepPreviousData: true
  })

  return (
    <div>
      <input
        type="text"
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder="Pesquisar..."
      />

      <div className={isLoading ? "loading" : ""}>
        {data?.products.map(item => <Product key={item.id} name={item.name} />)
      </div>
    </div>
  );
}
```

<Video
  src="https://user-images.githubusercontent.com/3676859/163695903-a3eb1259-180e-41e0-821e-21c320201194.mp4"
  caption="Preserve os resultados de pesquisa anteriores quando keepPreviousData estiver habilitado"
  ratio={640/730}
/>


D√™ uma olhada no c√≥digo no [CodeSandbox](https://codesandbox.io/s/swr-keeppreviousdata-fsjz3m) e voc√™ pode ler mais sobre isso [aqui](/docs/advanced/understanding#retorne-dados-antigos-para-melhorar-a-ux).

## Extendendo Configura√ß√µes [#extending-configurations]

O `SWRConfig` agora pode aceitar uma fun√ß√£o como valor. Quando voc√™ tem v√°rios n√≠veis de `<SWRConfig>`, o interno recebe a configura√ß√£o do pai e retorna uma nova. Essa mudan√ßa torna mais flex√≠vel configurar o SWR em uma codebase grande. Mais informa√ß√µes podem ser encontradas [aqui](/docs/global-configuration).

```jsx
<SWRConfig
  value={parentConfig => ({
    dedupingInterval: parentConfig.dedupingInterval * 5,
    refreshInterval: 100,
  })}
>
  <Page />
</SWRConfig>
```

## Suporte Melhorado ao React 18 [#improved-react-18-support]

SWR has updated its internal code to use `useSyncExternalStore` and `startTransition` APIs in React 18. These ensure stronger consistency when rendering UI concurrently. This change doesn‚Äôt require any user code changes and all developers will benefit from it directly. Shims are included for React 17 and below.

O SWR atualizou seu c√≥digo interno para usar o `useSyncExternalStore` e as `startTransition` APIs no React 18. Isso garante uma consist√™ncia mais forte ao renderizar a UI concorrentemente. Essa mudan√ßa n√£o requer nenhuma altera√ß√£o no c√≥digo do usu√°rio e todos os desenvolvedores se beneficiar√£o diretamente. Shims s√£o inclu√≠dos para o React 17 e abaixo.

SWR 2.0 e todas as novas funcionalidades ainda s√£o compat√≠veis com o React 16 e 17.

## Guia de Migra√ß√£o [#migration-guide]

### Fetcher n√£o recebe mais m√∫ltiplos argumentos [#fetcher-no-longer-accepts-multiple-arguments]

`key` agora √© passado como um argumento √∫nico.

```diff
- useSWR([1, 2, 3], (a, b, c) => {
+ useSWR([1, 2, 3], ([a, b, c]) => {
  assert(a === 1)
  assert(b === 2)
  assert(c === 3)
})
```

### Muta√ß√£o Global n√£o recebe mais uma fun√ß√£o `getKey` [#global-mutate-no-longer-accepts-a-getkey-function]

Agora, se voc√™ passar uma fun√ß√£o para o `mutate` global, ela ser√° usada como um [filtro](/blog/swr-v2##modificando-m√∫ltiplos-items). Anteriormente, voc√™ podia passar uma fun√ß√£o que retornasse uma chave para o `mutate` global:

```diff
- mutate(() => '/api/item') // uma fun√ß√£o para retornar a chave
+ mutate('/api/item')       // para modificar a chave, passe-a diretamente
```

### Nova propriedade obrigat√≥ria `keys()` para a interface Cache [#new-required-property-keys-for-cache-interface]

Quando voc√™ usar sua pr√≥pria implementa√ß√£o de cache, a interface Cache agora requer um m√©todo `keys()` que retorna todas as chaves no objeto cache, similar √†s inst√¢ncias Map do JavaScript.

```diff
interface Cache<Data> {
  get(key: string): Data | undefined
  set(key: string, value: Data): void
  delete(key: string): void
+ keys(): IterableIterator<string>
}
```

### Estrutura interna do Cache alterada [#changed-cache-internal-structure]

A estrutura interna dos dados do cache ser√° um objeto que cont√©m todos os estados atuais.

```diff
- assert(cache.get(key) === data)
+ assert(cache.get(key) === { data, error, isValidating })

// getter
- cache.get(key)
+ cache.get(key)?.data

// setter
- cache.set(key, data)
+ cache.set(key, { ...cache.get(key), data })
```

<Callout emoji="üö®" type="error">
  Voc√™ n√£o deveria escrever no cache diretamente, isso pode causar comportamento indefinido.
</Callout>

### `SWRConfig.default` Foi Renomeado para `SWRConfig.defaultValue` [#swrconfigdefault-is-renamed-as-swrconfigdefaultvalue]

O `SWRConfig.defaultValue` √© a propriedade para acessar a configura√ß√£o padr√£o do SWR.

```diff
- SWRConfig.default
+ SWRConfig.defaultValue
```

### O tipo `InfiniteFetcher` foi renomeado para `SWRInfiniteFetcher` [#type-infinitefetcher-is-renamed-as-swrinfinitefetcher]

```diff
- import type { InfiniteFetcher } from 'swr/infinite'
+ import type { SWRInfiniteFetcher } from 'swr/infinite'
```

### Evitando Suspense no Servidor [#avoid-suspense-on-server]

Se voc√™ quer usar `suspense: true` com o SWR no lado do servidor, incluindo pr√©-renderiza√ß√£o no Next.js, ent√£o voc√™ deve fornecer dados iniciais via [`fallbackData` ou `fallback`](/docs/with-nextjs#pr√©-renderizando-com-dados-padr√£o).

Hoje, isso significa que voc√™ n√£o pode usar Suspense para buscar dados no lado do servidor. Suas outras duas op√ß√µes s√£o fazer a busca de dados totalmente no lado do cliente ou obter seu framework para buscar os dados para voc√™ (como getStaticProps faz no Next.js).

### ES2018 como alvo de compila√ß√£o [#es2018-as-the-build-target]

Se voc√™ quiser dar suporte ao IE 11, voc√™ deve definir o ES5 como alvo de compila√ß√£o em seu framework ou bundler. Essa mudan√ßa fez uma melhoria de desempenho no SSR e mant√©m o tamanho do pacote pequeno.

## Changelog [#changelog]

Leia o Changelog completo [no GitHub](https://github.com/vercel/swr/releases).

## O futuro e Obrigado! [#the-future--thank-you]

Com o novo lan√ßamento do [Next.js 13](https://nextjs.org/blog/next-13), vemos muitas coisas novas e emocionantes, al√©m de mudan√ßas de paradigma no ecossistema React: [React Server Components](https://beta.nextjs.org/docs/rendering/server-and-client-components), streaming SSR, [async components](https://beta.nextjs.org/docs/data-fetching/fetching#asyncawait-in-server-components), e o [hook `use`](https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md#usepromise). Muitos deles est√£o relacionados ao data-fetching, e alguns deles t√™m casos de uso semelhantes com o SWR.

No entanto, o objetivo do projeto SWR permanece o mesmo. Queremos que seja uma biblioteca drop-in que seja leve, agn√≥stica de framework e um pouco _opinativa_ (por exemplo, revalidar ao foco). Em vez de tentar ser uma solu√ß√£o padr√£o, queremos nos concentrar em inova√ß√µes que melhorem a UX. Enquanto isso, tamb√©m estamos fazendo pesquisas sobre como melhorar o SWR com essas novas capacidades do React.

Queremos agradecer a cada um dos [143](https://github.com/vercel/swr/graphs/contributors) contribuidores (+ [106](https://github.com/vercel/swr-site/graphs/contributors) contribuidores de documenta√ß√£o), bem como aqueles que nos ajudam ou nos d√£o feedback. Um agradecimento especial vai para [Toru Kobayashi](https://twitter.com/koba04) por todo o seu trabalho nos DevTools e na documenta√ß√£o - n√£o ter√≠amos conseguido sem voc√™!