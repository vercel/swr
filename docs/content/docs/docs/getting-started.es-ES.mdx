import { Callout, Tabs, Tab } from 'nextra-theme-docs'
import Link from 'next/link'

# Comienza

## Instalaci칩n [#installation]

Dentro del directorio de su proyecto React, ejecute lo siguiente:

<Tabs items={['pnpm', 'npm', 'yarn']}>
  <Tab>
    ```bash
    pnpm add swr
    ```
  </Tab>
  <Tab>
    ```bash
    npm i swr
    ```
  </Tab>
  <Tab>
    ```bash
    yarn add swr
    ```
  </Tab>
</Tabs>

## Inicio r치pido [#quick-start]

Para APIs RESTFul normales con datos JSON, primero necesita crear una funci칩n `fetcher`, que no es m치s que una envoltura
del `fetch` nativo:

```jsx
const fetcher = (...args) => fetch(...args).then(res => res.json())
```

<Callout emoji="游눠">
    Si tu quieres usar API GraphQL o librer칤as como Axios, puedes crear tu propia funci칩n fetcher. Consulta
    <Link href="/docs/data-fetching">aqui</Link> para ver m치s ejemplos.
</Callout>

Luego puede importar `useSWR` y empezar a usarlo dentro de cualquier componente de la funci칩n:

```jsx
import useSWR from "swr"

function Profile ({ userId }) {
  const { data, error, isLoading } = useSWR(`/api/user/${userId}`, fetcher)

  if (error) return <div>failed to load</div>
  if (isLoading) return <div>loading...</div>

  // renderizar datos
  return <div>hello {data.name}!</div>
}
```

Normalmente, hay 3 estados posibles de una solicitud: "loading", "ready", o "error". Puedes utilizar el valor
`data`, `error` y `isLoading` para determinar el estado actual de la solicitud, y devolver la UI correspondiente.

## H치galo reutilizable [#make-it-reusable]

Cuando construye una aplicaci칩n web, es posible que haya que reutilizar los datos en muchos lugares de la UI.
Es incre칤blemente f치cil crear hooks de datos reutilizables sobre SWR:

```jsx

function useUser (id) {
    const { data, error, isLoading } = useSWR(`/api/user/${id}`, fetcher)

    return {
        user: data,
        isLoading,
        isError: error
    }
}

```

Y util칤celo en sus componentes:

```jsx

function Avatar({ id }) {
   const { user, isLoading, isError } = useUser(id)

   if(isLoading) return <Spinner />
   if (isError) return <Error />
   return <img src={user.avatar} />
}

```

Al adoptar este patr칩n, puede olvidarse del **fetching** de datos de forma imperativa: inicie la solicitud,
actualice el estado de carga, y devuelve el resultado final. En cambio, su c칩digo es m치s declarativo: s칩lo hay
que especificar qu칠 datos utiliza el componente.

## Ejemplo [#example]

En un ejemplo del mundo real, nuestro sitio web muestra una barra de navegaci칩n y el contenido,
ambos dependen del `user`:

import { Welcome } from 'components/diagrams/welcome'

<div className="mt-8">
  <Welcome/>
</div>

Tradicionalmente, obtenemos los datos una vez utilizando `useEffect` en el componente de nivel superior, y pasarlo a los componentes hijos
a trav칠s de props (f칤jate que por ahora no manejamos el estado de error):

```jsx {7-11,17,18,27}
// componente de la p치gina

function Page ({ userId }) {
  const [user, setUser] = useState(null)

  // obtener datos
  useEffect(() => {
    fetch(`/api/user/${userId}`)
      .then(res => res.json())
      .then(data => setUser(data))
  }, [userId])

  // estado de carga global
  if (!user) return <Spinner />

  return (
    <div>
      <Navbar user={user} />
      <Content user={user} />
    </div>
  )
}

// componentes hijos

function Navbar({ user }) {
  return (
    <div>
      ...
      <Avatar user={user} />
    </div>
  )
}

function Content({ user }) {
  return <h1>Welcome back, {user.name}</h1>
}

function Avatar({ user }) {
  return <img src={user.avatar} alt={user.name} />
}
```

Por lo general, necesitamos mantener todos los datos que se obtienen en el componente de nivel superior y
a침adir las props a cada componente dentro del 치rbol. El c칩digo ser치 m치s dif칤cil de mantener si a침adimos m치s
dependencia de datos a la p치gina.

Aunque podamos evitar pasar props usando [Context](https://react.dev/learn/passing-data-deeply-with-context), sigue existiendo problema con el contenido din치mico:
Los componentes dentro del contenido de la p치gina pueden ser din치micos, y componente de nivel superiror puede no saber qu칠 datos necesitar치n sus componentes hijos.

SWR resuelve el problema perfectamente, Con el hook `useUser` que acabamos de crear, el c칩digo puede ser refactorizado a:

```jsx {20,26}

// componente de la p치gina

function Page ({ userId }) {
  return <div>
    <Navbar userId={userId} />
    <Content userId={userId} />
  </div>
}

// componentes hijos

function Navbar ({ userId }) {
  return <div>
    ...
    <Avatar userId={userId} />
  </div>
}

function Content ({ userId }) {
  const { user, isLoading } = useUser(userId)
  if (isLoading) return <Spinner />
  return <h1>Welcome back, {user.name}</h1>
}

function Avatar ({ userId }) {
  const { user, isLoading } = useUser(userId)
  if (isLoading) return <Spinner />
  return <img src={user.avatar} alt={user.name} />
}

```

Los datos ahora est치n vinculados a los componentes que los necesitan, y todos los componentes son independientes entre s칤.
Todos los componentes padre no necesitan saber nada sobre los datos o el paso del mismo. S칩lo se renderizaran. El c칩digo es mucho
m치s sencillo y f치cil de mantener ahora.

Lo m치s bonito es que s칩lo se enviar치 **1 request** a la API, porque utilizan la misma clave de SWR y la solicitud se **desduplica**,
se almacena en **cach칠** y se **comparte** autom치ticamente.

Tambi칠n, la aplicaci칩n tiene ahora la capacidad de volver a obtener los datos cuando [el usuario se centra o se reconecta a la red!](/docs/revalidation)
Esto significa que, cuando el laptop del usuario se despierte de la suspensi칩n o cambie de pesta침a del navegador, los datos se actualizar치n autom치ticamente.
