import { Callout } from 'nextra-theme-docs'

# Pagina√ß√£o

<Callout emoji="‚úÖ">
    Por favor atualize para a vers√£o mais recente (‚â• 0.3.0) para usar esta API. A API anterior <code>useSWRPages</code> est√° descontinuada.
</Callout>

SWR prov√™ uma API `useSWRInfinite` dedicada para lidar com padr√µes de interface comuns como **pagina√ß√£o** e **carregamento infinito**.

## Quando Usar `useSWR` [#when-to-use-useswr]

### Pagina√ß√£o [#pagination]

Antes de tudo, n√≥s podemos **N√ÉO** precisar de `useSWRInfinite` mas podemos usar apenas `useSWR` se estamos construindo algo como isso:

import { Pagination } from 'components/diagrams/pagination'

<div className="mt-8">
  <Pagination/>
</div>

...que √© uma interface t√≠pica de pagina√ß√£o. Veja como pode ser facilmente implementado com `useSWR`:

```jsx {5}
function App () {
  const [pageIndex, setPageIndex] = useState(0);

  // A URL da API inclui o √≠ndice da p√°gina, que √© um estado do React.
  const { data } = useSWR(`/api/data?page=${pageIndex}`, fetcher);

  // ... lidando com estados de loading e erro

  return <div>
    {data.map(item => <div key={item.id}>{item.name}</div>)}
    <button onClick={() => setPageIndex(pageIndex - 1)}>Anterior</button>
    <button onClick={() => setPageIndex(pageIndex + 1)}>Pr√≥ximo</button>
  </div>
}
```

Al√©m disso, podemos criar uma abstra√ß√£o para este "componente de p√°gina":

```jsx {13}
function Page ({ index }) {
  const { data } = useSWR(`/api/data?page=${index}`, fetcher);

  // ... lidando com estados de loading e erro

  return data.map(item => <div key={item.id}>{item.name}</div>)
}

function App () {
  const [pageIndex, setPageIndex] = useState(0);

  return <div>
    <Page index={pageIndex}/>
    <button onClick={() => setPageIndex(pageIndex - 1)}>Anterior</button>
    <button onClick={() => setPageIndex(pageIndex + 1)}>Pr√≥ximo</button>
  </div>
}
```

Por causa do cache do SWR, temos o benef√≠cio de pr√©-carregar a pr√≥xima p√°gina. Renderizamos a pr√≥xima p√°gina dentro
um div oculto, SWR acionar√° a busca de dados da pr√≥xima p√°gina. Quando o usu√°rio navega para a pr√≥xima p√°gina, os dados j√° est√£o l√°:

```jsx {6}
function App () {
  const [pageIndex, setPageIndex] = useState(0);

  return <div>
    <Page index={pageIndex}/>
    <div style={{ display: 'none' }}><Page index={pageIndex + 1}/></div>
    <button onClick={() => setPageIndex(pageIndex - 1)}>Previous</button>
    <button onClick={() => setPageIndex(pageIndex + 1)}>Next</button>
  </div>
}
```

Com apenas 1 linha de c√≥digo, obtemos uma UX muito melhor. O hook `useSWR` √© t√£o poderoso que a maioria dos cen√°rios s√£o cobertos por ele.

### Carregamento Infinito [#infinite-loading]

√Äs vezes, queremos criar uma UI de **carregamento infinito**, com um bot√£o "Carregar mais" que anexa dados
para a lista (ou feito automaticamente quando voc√™ rola):

import { Infinite } from 'components/diagrams/infinite'

<div className="mt-8">
  <Infinite/>
</div>

Para implementar isso, precisamos fazer um **n√∫mero din√¢mico de solicita√ß√µes** nesta p√°gina. Os React Hooks tem [algumas regras](https://pt-br.reactjs.org/docs/hooks-rules.html),
ent√£o n√≥s **N√ÉO PODEMOS** fazer algo assim:

```jsx {5,6,7,8,9}
function App () {
  const [cnt, setCnt] = useState(1)

  const list = []
  for (let i = 0; i < cnt; i++) {
    // üö® Isso √© errado! Comumente, voc√™ n√£o pode usar hooks dentro de um loop.
    const { data } = useSWR(`/api/data?page=${i}`)
    list.push(data)
  }

  return <div>
    {list.map((data, i) =>
      <div key={i}>{
        data.map(item => <div key={item.id}>{item.name}</div>)
      }</div>)}
    <button onClick={() => setCnt(cnt + 1)}>Carregar mais</button>
  </div>
}
```

Ao inv√©s disso, podemos usar a abstra√ß√£o `<Page />` que criamos para conseguir isso:

```jsx {5,6,7}
function App () {
  const [cnt, setCnt] = useState(1)

  const pages = []
  for (let i = 0; i < cnt; i++) {
    pages.push(<Page index={i} key={i} />)
  }

  return <div>
    {pages}
    <button onClick={() => setCnt(cnt + 1)}>Carregar mais</button>
  </div>
}
```

### Casos Avan√ßados [#advanced-cases]

Entretanto, em alguns casos avan√ßados, a solu√ß√£o acima n√£o funciona.

Por exemplo, n√≥s ainda estamos implementando o mesmo "Carregar mais", mas tamb√©m precisamos mostrar um n√∫mero
sobre quantos itens existem no total. N√≥s n√£o podemos usar o `<Page />` novamente porque
a top level UI (`<App />`) precisa dos dados dentro de cada p√°gina:

```jsx {10}
function App () {
  const [cnt, setCnt] = useState(1)

  const pages = []
  for (let i = 0; i < cnt; i++) {
    pages.push(<Page index={i} key={i} />)
  }

  return <div>
    <p>??? items</p>
    {pages}
    <button onClick={() => setCnt(cnt + 1)}>Carregar mais</button>
  </div>
}
```

Tamb√©m, se a API de pagina√ß√£o for **baseada em cursor**, essa solu√ß√£o n√£o funciona tamb√©m. Porque cada p√°gina
precisa dos dados da p√°gina interior, elas n√£o s√£o isoladas.

√â assim que esse novo hook `useSWRInfinite` pode ajudar.

## useSWRInfinite [#useswrinfinite]

`useSWRInfinite` nos d√° a habilidade de disparar uma quantidade de solicita√ß√µes com um Hook. Isso √© como se fosse:

```jsx
import useSWRInfinite from 'swr/infinite'

// ...
const { data, error, isLoading, isValidating, mutate, size, setSize } = useSWRInfinite(
  getKey, fetcher?, options?
)
```

Similar ao `useSWR`, esse novo Hook aceita uma fun√ß√£o que retorna a chave de pedido, uma fun√ß√£o de busca, e op√ß√µes.
Ele retorna todos os valores que `useSWR` retorna, incluindo 2 valores extras: o tamanho da p√°gina e um setter do tamanho da p√°gina, como um state do React.

No carregamento infinito, uma _p√°gina_ √© uma requisi√ß√£o, e nosso objetivo √© buscar m√∫ltiplas p√°ginas e renderiz√°-las.

<Callout emoji="‚ö†Ô∏è">
  Se voc√™ est√° usando vers√µes SWR 0.x, `useSWRInfinite` precisa ser importado de `swr`:<br/>
  `import { useSWRInfinite } from 'swr'`
</Callout>

### API [#api]

#### Par√¢metros [#parameters]

- `getKey`: uma fun√ß√£o que aceita o √≠ndice e os dados da p√°gina anterior, retorna a chave de uma p√°gina
- `fetcher`: mesma fun√ß√£o que a [fun√ß√£o fetcher](/docs/data-fetching) do `useSWR`.
- `options`: aceita todas as op√ß√µes que `useSWR` suporta, com 4 op√ß√µes adicionais:
  - `initialSize=1`: n√∫mero de p√°ginas devem ser carregadas inicialmente
  - `revalidateAll=false`: sempre tentar revalidar todas as p√°ginas
  - `revalidateFirstPage=true`: sempre tentar revalidar a primeira p√°gina
  - `persistSize=false`: n√£o reseta o tamanho da p√°gina para 1 (ou `initialSize` se setado) quando a chave da primeira p√°gina muda
  - `parallel = false`: carrega m√∫ltiplas p√°ginas em paralelo

<Callout>
  Note que a op√ß√£o `initialSize` n√£o √© permitida a mudar no ciclo de vida.
</Callout>

#### Valores de Retorno [#return-values]

- `data`: um array de respostas de fetch para cada p√°gina
- `error`: mesma que o objeto `error` do `useSWR`.
- `isLoading`: mesmo que o `isLoading` do `useSWR`.
- `isValidating`: mesmo que o `isValidating` do `useSWR`.
- `mutate`: igual √† fun√ß√£o de muta√ß√£o vinculada do `useSWR`, mas manipula o array de dados
- `size`: o n√∫mero de p√°ginas que _v√£o_ ser carregadas e retornadas
- `setSize`: define o n√∫mero de p√°ginas que precisam ser carregadas

### Exemplo 1: API de Pagina√ß√£o Baseada em √çndice [#example-1-index-based-paginated-api]

Para APIs baseadas em √≠ndice:

```plaintext
GET /users?page=0&limit=10
[
  { name: 'Alice', ... },
  { name: 'Bob', ... },
  { name: 'Cathy', ... },
  ...
]
```

```jsx {4,5,6,7,10}
// A fun√ß√£o para obter a chave SWR de cada p√°gina,
// o valor retornado ser√° aceito pela fun√ß√£o `fetcher`.
// Se o valor `null` √© retornado, a solicita√ß√£o da p√°gina n√£o iniciar√°.
const getKey = (pageIndex, previousPageData) => {
  if (previousPageData && !previousPageData.length) return null // atingiu o fim
  return `/users?page=${pageIndex}&limit=10`                    // chave SWR
}

function App () {
  const { data, size, setSize } = useSWRInfinite(getKey, fetcher)
  if (!data) return 'loading'

  // Agora podemos calcular o n√∫mero total de usu√°rios
  let totalUsers = 0
  for (let i = 0; i < data.length; i++) {
    totalUsers += data[i].length
  }

  return <div>
    <p>{totalUsers} users listed</p>
    {data.map((users, index) => {
      // `data` √© um array de respostas da API de cada p√°gina.
      return users.map(user => <div key={user.id}>{user.name}</div>)
    })}
    <button onClick={() => setSize(size + 1)}>Carregar mais</button>
  </div>
}
```

A fun√ß√£o `getKey` √© a diferen√ßa maior entre `useSWRInfinite` e `useSWR`.
Ela aceita o √≠ndice da p√°gina atual, bem como os dados da p√°gina anterior.
Ent√£o ambas (pagina√ß√£o baseada em √≠ndice e p√°gina√ß√£o baseada em cursor) podem ser suportadas.

Tamb√©m, `data` n√£o √© mais apenas uma resposta da API. √â um array de respostas da API:

```js
// `data` se parecer√° com isso
[
  [
    { name: 'Alice', ... },
    { name: 'Bob', ... },
    { name: 'Cathy', ... },
    ...
  ],
  [
    { name: 'John', ... },
    { name: 'Paul', ... },
    { name: 'George', ... },
    ...
  ],
  ...
]
```

### Exemplo 2: API de Pagina√ß√£o Baseada em Cursor ou Offset [#example-2-cursor-or-offset-based-paginated-api]

Vamos dizer que a API agora requer um cursor e retorna o pr√≥ximo cursor junto com os dados:

```plaintext
GET /users?cursor=123&limit=10
{
  data: [
    { name: 'Alice' },
    { name: 'Bob' },
    { name: 'Cathy' },
    ...
  ],
  nextCursor: 456
}
```

N√≥s podemos mudar nossa fun√ß√£o `getKey` para:

```jsx
const getKey = (pageIndex, previousPageData) => {
  // alcan√ßou o fim
  if (previousPageData && !previousPageData.data) return null

  // primeira p√°gina, n√≥s n√£o temos `previousPageData`
  if (pageIndex === 0) return `/users?limit=10`

  // adiciona o cursor para o endpoint da API
  return `/users?cursor=${previousPageData.nextCursor}&limit=10`
}
```

### Modo de Carregamento Paralelo [#parallel-fetching-mode]

<Callout emoji="‚úÖ">
  Por favor atualize para a √∫ltima vers√£o (‚â• 2.1.0) para usar essa API.
</Callout>


O comportamento padr√£o do `useSWRInfinite` √© de obter dados para cada p√°gina em sequ√™nciaa, pois a cria√ß√£o de chaves √© baseada nos dados previamente obtidos. No entanto, fazer fetching de dados sequencialmente para um grande n√∫mero de p√°ginas pode n√£o ser otimizado, particularmente se as p√°ginas n√£o s√£o interdependentes.

Ao especificar a op√ß√£o `parallel` como `true`, voc√™ poder√° obter p√°ginas independentemente em paralelo, o que pode acelerar significativamente o processo de carregamento.

```jsx
// parallel = false (default)
// page1 ===> page2 ===> page3 ===> feito
//
// parallel = true
// page1 ==> feito
// page2 =====> feito
// page3 ===> feito
//
// previousPageData √© sempre `null`
const getKey = (pageIndex, previousPageData) => {
  return `/users?page=${pageIndex}&limit=10`
}

function App () {
  const { data } = useSWRInfinite(getKey, fetcher, { parallel: true })
}
```

<Callout emoji="‚ö†Ô∏è">
    O argumento `previousPageData` da fun√ß√£o `getKey` se torna `null` quando voc√™ habilita a op√ß√£o `parallel`.
</Callout>

### Revalidate Specific Pages [#revalidate-specific-pages]

<Callout emoji="‚úÖ">
  Please update to the latest version (‚â• 2.2.5) to use this API.
</Callout>

The default behavior of the mutation of `useSWRInfinite` is to revalidate all pages that have been loaded. But you might want to revalidate only the specific pages that have been changed. You can revalidate only specific pages by passing a function to the `revalidate` option.

The `revalidate` function is called for each page.

```jsx
function App() {
  const { data, mutate, size } = useSWRInfinite(
    (index) => [`/api/?page=${index + 1}`, index + 1],
    fetcher
  );

  mutate(data, {
    // only revalidate the last page
    revalidate: (pageData, [url, page]) => page === size
  });
}
```

### Muta√ß√£o Global com `useSWRInfinite` [#global-mutate-with-useswrinfinite]

`useSWRInfinite` armazena todos os dados da p√°gina com uma chave de cache especial junto com cada dado da p√°gina. Voc√™ deve usar `unstable_serialize` em `swr/infinite` para revalidar os dados com a muta√ß√£o global.

```jsx
import { useSWRConfig } from "swr"
import { unstable_serialize } from "swr/infinite"

function App() {
    const { mutate } = useSWRConfig()
    mutate(unstable_serialize(getKey))
}
````

<Callout emoji="‚ö†Ô∏è">
    Como o nome indica, `unstable_serialize` n√£o √© uma API est√°vel, ent√£o podemos mud√°-la no futuro.
</Callout>

### Funcionalidades Avan√ßadas [#advanced-features]

Um exemplo mostrando como voc√™ pode implementar as seguintes funcionalidades com `useSWRInfinite` [est√° dispon√≠vel aqui](/examples/infinite-loading):

- Estados de carregamento
- Mostrar uma interface especial se estiver vazio
- Desativar o bot√£o "Carregar mais" se alcan√ßou o fim
- Fonte de dados alter√°vel
- Atualizar toda a lista
