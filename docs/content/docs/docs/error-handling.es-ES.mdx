import { Callout } from 'nextra-theme-docs'
import Link from 'next/link'

# Gesti贸n De Errores

Si se lanza un error dentro del [`fetcher`](/docs/data-fetching), ser谩 devuelto como `error` por el hook.

```js
const fetcher = url => fetch(url).then(r => res.json())

// ...
const { data, error } = useSWR('/api/user', fetcher)
```

El objeto `error` ser谩 definido si la promise de fetch es rechazada.

## C贸digo de estado y objeto de error [#status-code-and-error-object]

A veces queremos que una API devuelva un objeto de error junto con el status code.
Ambos son 煤tiles para el cliente.

Podemos personanilizar nuestro `fetcher` para que devuelve m谩s informaci贸n. Si el status code no es `2xx`, lo consideramos
un error aunque se pueda analizar como JSON:

```js
const fetcher = async url => {
  const res = await fetch(url)

  // Si el status code no esta en el rango 200-299,
  // seguimos intentando analizarlo y lanzarlo.
  if (!res.ok) {
    const error = new Error('An error occurred while fetching the data.')
    // Adjunta informaci贸n extra al objeto de error.
    error.info = await res.json()
    error.status = res.status
    throw error
  }

  return res.json()
}

// ...
const { data, error } = useSWR('/api/user', fetcher)
// error.info === {
//   message: "You are not authorized to access this resource.",
//   documentation_url: "..."
// }
// error.status === 403

```

<Callout emoji="">
  Tenga en cuenta que `data` y `error` pueden existir al mismo tiempo. Por lo tanto la UI puede mostrar
  data existente, mientras se sabe que la pr贸xima solicitud ha fallado.
</Callout>

[Aqu铆](/examples/error-handling) tenemos un ejemplo.

## Reintento de error [#error-retry]

SWR utiliza el [exponential backoff algorithm](https://en.wikipedia.org/wiki/Exponential_backoff) para reintentar la solicitud en el error.
El algoritmo permite que la aplicaci贸n se recupere de los errores r谩pidamente, pero si malgastar recursos reintentando con demasiada frecuencia.

Tambi茅n podemos anular este comportamiento mediante la opci贸n [onErrorRetry](/docs/api#options):

```js
useSWR('/api/user', fetcher, {
  onErrorRetry: (error, key, config, revalidate, { retryCount }) => {
    // Never retry on 404.
    if (error.status === 404) return

    // Never retry for a specific key.
    if (key === '/api/user') return

    // Only retry up to 10 times.
    if (retryCount >= 10) return

    // Retry after 5 seconds.
    setTimeout(() => revalidate({ retryCount }), 5000)
  }
})
```

Este callback le da flexibilidad de reintentar basado en varias condiciones. Tambi茅n puede desactivar estableciendo `shouldRetryOnError: false`.

Tambi茅n es posible propocionar a trav茅s del [Global Configuration](/docs/global-configuration) context.

## Informe global de errores [#global-error-report]

Siempre puedes obtener el objeto de `error` dentro del componente de forma reactiva. Pero en caso de que quieras manejar el error de forma global,
para notificar a la UI que muestre un [toast](https://vercel.com/design/toast) o un [snackbar](https://material.io/components/snackbars), o reportarlo
en alg煤n lugar como [Sentry](https://sentry.io), hay un evento [`onError`](/docs/api#options):

```jsx
<SWRConfig value={{
  onError: (error, key) => {
    if (error.status !== 403 && error.status !== 404) {
      // Podemos enviar el error a Sentry
      // o mostrarlo una notificaci贸n UI.
    }
  }
}}>
  <MyApp />
</SWRConfig>
```
